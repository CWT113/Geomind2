# 查询操作

## 查询全部

::: code-group

```java [UserMapper]
public interface UserMapper {
  // 查询结果以 List 集合接收
  List<User> getAllUser();

  // 查询结果以 Map<String, Object> 接收，并使用 @MapKey("id") 指定Map中键为id，值为查询的当前结果列
  @MapKey("id")
  Map<String, Object> getUserByGender(@Param("gender") String gender);

  // 查询结果以 List<Map<String, Object>> 的方式接收返回值
  @MapKey("id")
  List<Map<String, Object>> getUserByGender1(@Param("gender") String gender);
}
```

```xml [UserMapper.xml]
<mapper namespace="com.geomind.mapper.UserMapper">
  <select id="getAllUser" resultType="User">
    select * from tb_user;
  </select>

  <select id="getUserByGender" resultType="Map">
    select * from tb_user where gender = #{gender};
  </select>

  <select id="getUserByGender1" resultType="Map">
    select * from tb_user where gender = #{gender};
  </select>
</mapper>
```

```java [UserMapperTest] {4,13,20}
@Test
public void testGetAllUser() {
  UserMapper mapper = SqlSessionUtils.getMapper(UserMapper.class);
  List<User> users = mapper.getAllUser();
  for (User user : users) {
    System.out.println(user);
  }
}

@Test
public void testGetUserByGender() {
  UserMapper mapper = SqlSessionUtils.getMapper(UserMapper.class);
  Map<String, Object> map = mapper.getUserByGender("女");
  map.values().forEach(System.out::println);
}

@Test
public void testGetUserByGender() {
  UserMapper mapper = SqlSessionUtils.getMapper(UserMapper.class);
  List<Map<String, Object>> list = mapper.getUserByGender("女");
  System.out.println("list = " + list);
}
```

:::



::: tip `@MapKey` 注解的作用？

`@MapKey` 注解用在返回类型为 Map 的 mapper 方法上，用于指定返回值为 Map 时，其中的 key 应该用查询结果中的那一列（最好以唯一的列作为 key，比如 id 字段）。

```java
// 表示查询的结果是一个 Map 集合，其中键为 id 字段的值，值为当前行的数据
@MapKey("id")
Map<String, Object> getUserByGender(@Param("gender") String gender);
```

:::



## 查询详情

查询详情时，一般查询的结果只会存在一条，此时接收查询结果的方式有三种：

- 通过实体类对象接收，如 `User`；
- 通过 `List` 集合的方式接收，如 `List<User>`；
- 通过 `Map` 集合的方式接收，如 `Map<String, Object>`；

::: code-group

```java [UserMapper]
public interface UserMapper {
  // 查询详情的结果只有一条数据时，使用实体类接收
  User getUserById(@Param("id") Integer id);

  // 查询详情的结果有一条或多条时，使用 List 集合接收
  List<User> getUserByUsername(@Param("username") String username);
  
  // 查询详情的结果只有一条时，可以使用 Map<String, Object> 接收，其中 key 是字段名，value 是字段值
  Map<String, Object> getUserByGender(@Param("gender") String gender);
}
```

```xml [UserMapper.xml]
<mapper namespace="com.geomind.mapper.UserMapper">
  <select id="getUserById" resultType="User">
    select * from tb_user where id = #{id};
  </select>

  <select id="getUserByUsername" resultType="User">
    select * from tb_user where username = #{username};
  </select>

  <select id="getUserByGender" resultType="Map">
    select * from tb_user where gender = #{gender};
  </select>
</mapper>
```

```java [UserMapperTest] {5,12,19}
public class UserTest {
  @Test
  public void testGetUserById() {
    UserMapper mapper = SqlSessionUtils.getMapper(UserMapper.class);
    User user = mapper.getUserById(10);
    System.out.println("user = " + user);
  }

  @Test
  public void testGetUserByUsername() {
    UserMapper mapper = SqlSessionUtils.getMapper(UserMapper.class);
    List<User> users = mapper.getUserByUsername("李四");
    System.out.println("user = " + users);
  }

  @Test
  public void testGetUserByGender() {
    UserMapper mapper = SqlSessionUtils.getMapper(UserMapper.class);
    Map<String, Object> map = mapper.getUserByGender("女");
    System.out.println("map = " + map);
  }
}

```

:::



## 单行单列

单行单列查询时，`<Select>` 标签的 `resultType` 属性可以写，也可以不写，也可以写 [类型别名](https://mybatis.net.cn/configuration.html#typeAliases)。

::: code-group

```java [UserMapper]
public interface UserMapper {
  Integer getCount();
}
```

```xml [UserMapper.xml]
<mapper namespace="com.geomind.mapper.UserMapper">
  <!-- resultType 可以不写，也可以写 Integer 本身或它的类型别名 -->
  <select id="getCount" resultType="Integer">
    select count(*) from tb_user;
  </select>
</mapper>
```

```java [UserMapperTest] {4}
@Test
public void testGetCount() {
  UserMapper mapper = SqlSessionUtils.getMapper(UserMapper.class);
  Integer count = mapper.getCount();
  System.out.println("count = " + count);
}
```

:::



## 多条件查询

### @Param注解

::: code-group

```java [BreadMapper]
public interface BreadMapper {
  List<Brand> selectByCondition(@Param("status") Integer status,
                                @Param("brandName") String brandName,
                                @Param("companyName") String companyName);
}
```

```xml [BreadMapper]
<select id="selectByCondition" resultMap="brandResultMap">
  select *
  from tb_brand
  where status = #{status}
    and brand_name like #{brandName}
    and company_name like #{companyName};
</select>
```

```java [BrandTest] {16,17,20}
@Test
public void testSelectByCondition() throws IOException {
  String resource = "mybatis-config.xml";
  InputStream inputStream = Resources.getResourceAsStream(resource);
  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

  SqlSession sqlSession = sqlSessionFactory.openSession();

  BreadMapper mapper = sqlSession.getMapper(BreadMapper.class);

  Integer status = 1;
  String brandName = "华为";
  String companyName = "华为";

  // 因为是模糊查询，所以需要拼接 %
  brandName = "%" + brandName + "%";
  companyName = "%" + companyName + "%";

  // 散装参数
  List<Brand> brands = mapper.selectByCondition(status, brandName, companyName);
  System.out.println(brands);

  sqlSession.close();
}
```

:::



### 实体类对象

实体类对象的方式，就是使用 pojo 类作为参数进行传递，此时类中的字段名称必须和表中的列名称对应。

::: code-group

```java [BreadMapper]
public interface BreadMapper {
  List<Brand> selectByCondition(Brand brand);
}
```

```xml [BreadMapper]
<select id="selectByCondition" resultMap="brandResultMap">
  select *
  from tb_brand
  where status = #{status}
    and brand_name like #{brandName}
    and company_name like #{companyName};
</select>
```

```java [BrandTest] {16,17,20-24}
@Test
public void testSelectByCondition() throws IOException {
  String resource = "mybatis-config.xml";
  InputStream inputStream = Resources.getResourceAsStream(resource);
  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

  SqlSession sqlSession = sqlSessionFactory.openSession();

  BreadMapper mapper = sqlSession.getMapper(BreadMapper.class);

  Integer status = 1;
  String brandName = "华为";
  String companyName = "华为";

  // 因为是模糊查询，所以需要拼接 %
  brandName = "%" + brandName + "%";
  companyName = "%" + companyName + "%";

  // 实体类封装参数
  Brand brand = new Brand();
  brand.setStatus(status);
  brand.setBrandName(brandName);
  brand.setCompanyName(companyName);
  List<Brand> brands = mapper.selectByCondition(brand);
  System.out.println(brands);

  sqlSession.close();
}
```

:::



### Map集合

Map集合方式就是使用原始的 `new HashMap()` 的方式，将查询参数添加到集合中，并将集合作为参数传递。

::: code-group

```java [BreadMapper]
public interface BreadMapper {
  List<Brand> selectByCondition(Map map);
}
```

```xml [BreadMapper]
<select id="selectByCondition" resultMap="brandResultMap">
  select *
  from tb_brand
  where status = #{status}
    and brand_name like #{brandName}
    and company_name like #{companyName};
</select>
```

```java [BrandTest] {16,17,20-24}
@Test
public void testSelectByCondition() throws IOException {
  String resource = "mybatis-config.xml";
  InputStream inputStream = Resources.getResourceAsStream(resource);
  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

  SqlSession sqlSession = sqlSessionFactory.openSession();

  BreadMapper mapper = sqlSession.getMapper(BreadMapper.class);

  Integer status = 1;
  String brandName = "华为";
  String companyName = "华为";

  // 因为是模糊查询，所以需要拼接 %
  brandName = "%" + brandName + "%";
  companyName = "%" + companyName + "%";

  // Map集合
  HashMap<String, Object> hashMap = new HashMap<>();
  hashMap.put("status", status);
  hashMap.put("brandName", brandName);
  hashMap.put("companyName", companyName);
  List<Brand> brands = mapper.selectByCondition(hashMap);
  System.out.println(brands);

  sqlSession.close();
}
```

:::



## 多条件动态查询

前面的 多条件查询 案例中，如果用户没有传递参数中的某一个字段，这时候查询结果就会为空，这时候就要通过动态 SQL 的方式解决。

动态 SQL 的条件表达式有四种：

- if
- choose (when, otherwise)
- trim (where, set)
- foreach



为了**解决上面参数可能不传递的情况**，可以使用 `<if>` 标签判断参数是否为空，为空时则不拼接 SQL。

```xml {5,7,8,10,11,13}
<select id="selectByCondition" resultMap="brandResultMap">
  select *
  from tb_brand
  where
  <if test="status != null">
    status = #{status}
  </if>
  <if test="brandName != null and brandName != '' ">
    and brand_name like #{brandName}
  </if>
  <if test="companyName != null and companyName != ''">
    and company_name like #{companyName};
  </if>
</select>
```



但是，使用了 `<if>` 标签之后，还是会存在问题，例如省略了 `status` 参数传递，则 `brandName` 条件一开始就是 and，会直接报错。

::: tip 解决方案

- 使用 `where 1 = 1` ，让条件语句恒成立：

  ```xml {4}
  <select id="selectByCondition" resultMap="brandResultMap">
    select *
    from tb_brand
    where 1 = 1
    <if test="status != null">
      status = #{status}
    </if>
    <if test="brandName != null and brandName != '' ">
      and brand_name like #{brandName}
    </if>
    <if test="companyName != null and companyName != ''">
      and company_name like #{companyName};
    </if>
  </select>
  ```

  

- MyBatis 为了解决这个问题，提供了 `<where>` 标签，改写为：

  ```xml {4,14}
  <select id="selectByCondition" resultMap="brandResultMap">
    select *
    from tb_brand
    <where>
      <if test="status != null">
        status = #{status}
      </if>
      <if test="brandName != null and brandName != '' ">
        and brand_name like #{brandName}
      </if>
      <if test="companyName != null and companyName != ''">
        and company_name like #{companyName};
      </if>
    </where>
  </select>
  ```

  

:::



## 单条件动态查询

但条件动态查询是指 查询条件可能有很多个，但是只对其中的某一个进行动态 SQL 拼接查询。这时候就可以使用动态 SQL 的 `choose (when, otherwise)` 条件语句了。



::: code-group

```java [BreadMapper]
public interface BreadMapper {
  List<Brand> selectSingle(Brand brand);
}
```

```xml [BreadMapper]
<select id="selectSingle" resultMap="brandResultMap">
  select *
  from tb_brand
  where
  <choose>
    <!-- when表示只对其中的一个生效，类似于 switch..case.. -->
    <when test="status != null">
      status = #{status}
    </when>
    <when test="brandName != null and brandName != '' ">
      brand_name like #{brandName}
    </when>
    <when test="companyName != null and companyName != ''">
      company_name like #{companyName};
    </when>
  </choose>
</select>
```

```java [BrandTest] {24,22,20}
@Test
public void testSelectSingle() throws IOException {
  String resource = "mybatis-config.xml";
  InputStream inputStream = Resources.getResourceAsStream(resource);
  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

  SqlSession sqlSession = sqlSessionFactory.openSession();

  BreadMapper mapper = sqlSession.getMapper(BreadMapper.class);

  Integer status = 1;
  String brandName = "华为";
  String companyName = "华为";

  // 因为是模糊查询，所以需要拼接 %
  brandName = "%" + brandName + "%";
  companyName = "%" + companyName + "%";

  // 实体类封装参数
  Brand brand = new Brand();
  // brand.setStatus(status);
  brand.setBrandName(brandName);
  // brand.setCompanyName(companyName);
  List<Brand> brands = mapper.selectSingle(brand);
  System.out.println(brands);

  // 4、释放资源
  sqlSession.close();
}
```

:::



上面的代码，还是会存在问题，如果用户没有传递任何参数时，就会报错。

::: tip 解决方案

- 使用 `<otherwise>` 标签，匹配条件不满足时的 SQL 语句：

  ```xml {15-17}
  <select id="selectSingle" resultMap="brandResultMap">
    select *
    from tb_brand
    where
    <choose>
      <when test="status != null">
        status = #{status}
      </when>
      <when test="brandName != null and brandName != '' ">
        brand_name like #{brandName}
      </when>
      <when test="companyName != null and companyName != ''">
        company_name like #{companyName};
      </when>
      <otherwise>
        1 = 1
      </otherwise>
    </choose>
  </select>
  ```

- 使用 `where` 标签，当 `<when>` 都不满足时，后续 SQL 都不显示：

  ```xml {4,16}
  <select id="selectSingle" resultMap="brandResultMap">
    select *
    from tb_brand
    <where>
      <choose>
        <when test="status != null">
          status = #{status}
        </when>
        <when test="brandName != null and brandName != '' ">
          brand_name like #{brandName}
        </when>
        <when test="companyName != null and companyName != ''">
          company_name like #{companyName};
        </when>
      </choose>
    </where>
  </select>
  ```

:::



