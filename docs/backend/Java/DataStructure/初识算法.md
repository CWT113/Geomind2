# 初识算法



## 二分查找入门

::: info 需求

在 **有序** 数组 A 内，查找目标值 `target` ：

- 如果找到，返回索引值；
- 如果没找到，返回 `-1`；

:::

算法思路：

| 算法描述 | 说明                                                         |
| :------: | ------------------------------------------------------------ |
|   前提   | 给定一个内含 n 个元素的 **有序** 数组 A，及一个目标值 target |
|    1     | 设置 $i = 0, j = n - 1$                                      |
|    2     | 如果 $i > j$，结束查找，没有找到                             |
|    3     | 设置 $m = floor(\frac{i + j}{2})$，$m$ 为中间索引，$floor$ 是向下取整（注意：<span style="color:#CC0000;">取中间索引是有 BUG 的</span>，详见 误区1） |
|    4     | 如果 $target < A_m$，则设置 $j = m - 1$，回到第 2 步执行     |
|    5     | 如果 $A_m < target$，则设置 $i = m + 1$，回到第 2 步执行     |
|    6     | 如果 $A_m = target$，结束查找，找到了                        |

::: code-group

```java {6,8} [版本一]
public static int binarySearchBasic(int[] arr, int target) {
  int i = 0, j = arr.length - 1;
  while (i <= j) {
    int m = (i + j) / 2; // [!code warning]
    if (target < arr[m]) { // 如果目标值小于中间值，则 j 要往前移动
      j = m - 1;
    } else if (target > arr[m]) { // 如果目标值大于中间值，则 i 要往后移动
      i = m + 1;
    } else { // 相等直接返回索引
      return m;
    }
  }
  return -1;
}
```

```java [版本二]
public static int binarySearchBasic(int[] arr, int target) {
  int i = 0, j = arr.length - 1;
  while (i <= j) {
    int m = (i + j) >>> 1; // [!code ++]
    if (target < arr[m]) {
      j = m - 1;
    } else if (target > arr[m]) {
      i = m + 1;
    } else {
      return m;
    }
  }
  return -1;
}
```

```java {2,3,6} [版本三]
public static int binarySearchAlternative(int[] arr, int target) {
  int i = 0, j = arr.length;
  while (i < j) {
    int m = (i + j) >>> 1;
    if (target < arr[m]) {
      j = m;
    } else if (arr[m] < target) {
      i = m + 1;
    } else {
      return m;
    }
  }
  return -1;
}
```

:::

::: details 误区 1：为什么第 3 步，m 的值不推荐使用 相加除 2 的方式获取？

当数组长度达到 `int` 类型的最大值时，相加后结果超出 `int` 范围，此时会导致结果变为负数。

> [!TIP]  解决方案
>
> 通过 `>>>` 位运算符，将负数结果的符号位右移变为整数，从而使结果继续处于 `int` 类型的范围内。

```java
@Test
void testDemo() {
  int i = Integer.MAX_VALUE / 2;
  int j = Integer.MAX_VALUE;

  int m = (i + j) / 2; // -536870913（变成了负数，而期望值并不应该是负数）
  System.out.println(m);

  int n = (i + j) >>> 1; // 1610612735（正确，因为位移运算会移动符号位）
  System.out.println(n);
}
```

:::













