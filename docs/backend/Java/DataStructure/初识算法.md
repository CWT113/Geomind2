# 初识算法



## 二分查找入门

::: info 需求

在 **有序** 数组 A 内，查找目标值 `target` ：

- 如果找到，返回索引值；
- 如果没找到，返回 `-1`；

:::

算法思路：

| 算法描述 | 说明                                                         |
| :------: | ------------------------------------------------------------ |
|   前提   | 给定一个内含 n 个元素的 **有序** 数组 A，及一个目标值 target |
|    1     | 设置 $i = 0, j = n - 1$                                      |
|    2     | 如果 $i > j$，结束查找，没有找到                             |
|    3     | 设置 $m = floor(\frac{i + j}{2})$，$m$ 为中间索引，$floor$ 是向下取整（<span style="color:#CC0000;">注意：取中间索引是有 BUG 的，详见 **误区1**</span>） |
|    4     | 如果 $target < A_m$，则设置 $j = m - 1$，回到第 2 步执行     |
|    5     | 如果 $A_m < target$，则设置 $i = m + 1$，回到第 2 步执行     |
|    6     | 如果 $A_m = target$，结束查找，找到了                        |

::: code-group

```java {6,8} [版本一]
public static int binarySearchBasic(int[] arr, int target) {
  int i = 0, j = arr.length - 1;
  while (i <= j) {
    int m = (i + j) / 2; // [!code warning]
    if (target < arr[m]) { // 如果目标值小于中间值，则 j 要往前移动
      j = m - 1;
    } else if (target > arr[m]) { // 如果目标值大于中间值，则 i 要往后移动
      i = m + 1;
    } else { // 相等直接返回索引
      return m;
    }
  }
  return -1;
}
```

```java [版本二]
public static int binarySearchBasic(int[] arr, int target) {
  int i = 0, j = arr.length - 1;
  while (i <= j) {
    int m = (i + j) >>> 1; // [!code ++]
    if (target < arr[m]) {
      j = m - 1;
    } else if (target > arr[m]) {
      i = m + 1;
    } else {
      return m;
    }
  }
  return -1;
}
```

```java {2,3,6} [版本三]
public static int binarySearchAlternative(int[] arr, int target) {
  int i = 0, j = arr.length;
  while (i < j) {
    int m = (i + j) >>> 1;
    if (target < arr[m]) {
      j = m;
    } else if (arr[m] < target) {
      i = m + 1;
    } else {
      return m;
    }
  }
  return -1;
}
```

:::

::: details 误区 1：为什么第 3 步，$m$ 的值不推荐使用 $floor(\frac{i + j}{2})$ 的方式获取？

**原因：** 当 $i$ 和 $j$ 都非常大时，并且二者相加超过了 `int` 类型能表示的最大值时，就会发生 **整数溢出**。此时 $i + j$ 的值会变成一个负数（因为最高位变成了 1，被解释为符号位了），然后再除以 2，得到的 $m$ 就是一个错误的负值。

> [!TIP]  解决方案
>
> 通过 `>>>` 无符号右移运算符，将二进制表示的所有位向右移动指定的位数，**高位补零**，正好等价于 除以 2 并向下取整的结果。

```java
@Test
void testDemo() {
  int i = Integer.MAX_VALUE / 2;
  int j = Integer.MAX_VALUE;

  int m = (i + j) / 2; // -536870913（变成了负数，因为i+j超过了int类型的最大值）
  System.out.println(m);

  int n = (i + j) >>> 1; // 1610612735（正确）
  System.out.println(n);
}
```

:::













