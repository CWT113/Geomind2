# 地图事件

Cesium 中根据事件的类型、用途，可以将事件分为三大类：

|      事件       |              类               | 描述                                                       |
| :-------------: | :---------------------------: | ---------------------------------------------------------- |
|  鼠标操作事件   |   `ScreenSpaceEventHandler`   | 鼠标左键、鼠标中键、鼠标右键操作                           |
| 通用 Event 事件 |           无具体类            | 该类通常在容器类内部实例化，并作为某个属性的类型被直接调用 |
|  相机控制事件   | `ScreenSpaceCameraController` | 该类通过与 CameraEventType 类配合实现相机的控制            |



## 鼠标事件

> [!TIP] 创建鼠标事件过程
>
> 1. 传递 `viewer.canvas` 参数，实例化 [`ScreenSpaceEventHandler`](https://cesium.com/learn/cesiumjs/ref-doc/ScreenSpaceEventHandler.html?classFilter=ScreenSpaceEventHandler) 类；
> 2. 使用 [`setInputAction()`](https://cesium.com/learn/cesiumjs/ref-doc/global.html#ScreenSpaceEventType) 方法设置鼠标事件，在回调函数中获取鼠标信息；



### 创建事件

通过 `ScreenSpaceEventHandler` 类进行事件实例化，注册事件和注销事件：

```typescript
const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

// 注册事件
handler.setInputAction((event) => {
  console.log(event);
}, cesium.ScreenSpaceEventType.LEFT_CLICK);

// 注销事件
handler.removeInputAction(cesium.ScreenSpaceEventType.LEFT_CLICK);
```

::: details 鼠标事件一览表

|     事件类型      |     作用     |
| :---------------: | :----------: |
|    LEFT_CLICK     |   左键单击   |
| LEFT_DOUBLE_CLICK |   左键双击   |
|     LEFT_DOWN     |   左键按下   |
|      LEFT_UP      |   左键弹起   |
|   MIDDLE_CLICK    |   中键单击   |
|    MIDDLE_DOWN    |   中键按下   |
|     MIDDLE_UP     |   中键弹起   |
|    RIGHT_CLICK    |   右键单击   |
|    RIGHT_DOWN     |   右键按下   |
|     RIGHT_UP      |   右键弹起   |
|    MOUSE_MOVE     | 鼠标移动事件 |
|       WHEEL       | 鼠标滚轮事件 |
|    PINCH_START    | 双指开始事件 |
|     PINCH_END     | 双指结束事件 |
|    PINCH_MOVE     | 双指更改事件 |

:::



### 获取鼠标坐标

> [!NOTE] 提示
>
> 在有地形的情况下，第一种方式在获取点坐标时，是有可能穿过地形拾取到后面物体上的，而第二种方式不会。

::: code-group

```typescript [方式一]
const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

handler.setInputAction((e) => {
  const pickPosition = viewer.scene.camera.pickEllipsoid(e.position);

  if (Cesium.defined(pickPosition)) {
    const cartographic = Cesium.Cartographic.fromCartesian(pickPosition);
    const lng = Cesium.Math.toDegrees(cartographic.longitude);
    const lat = Cesium.Math.toDegrees(cartographic.latitude);
    const height = cartographic.height;
    console.log({ lng, lat, height });
  }
}, cesium.ScreenSpaceEventType.LEFT_CLICK);
```

```typescript [方式二]
const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

handler.setInputAction((e) => {
  // 根据屏幕位置获取摄像机射线
  const ray = viewer.camera.getPickRay(e.position);
  // 获取射线与地球表面的交点
  const cartesian = viewer.scene.globe.pick(ray, viewer.scene);

  if (Cesium.defined(cartesian)) {
    const cartographic = Cesium.Cartographic.fromCartesian(pickPosition);
    const lng = Cesium.Math.toDegrees(cartographic.longitude);
    const lat = Cesium.Math.toDegrees(cartographic.latitude);
    const height = cartographic.height;
    console.log({ lng, lat, height });
  }
}, cesium.ScreenSpaceEventType.LEFT_CLICK);
```

:::



### 指定要素拾取

假设应用场景比较复杂，存在 Entity、Primitive、Model、3D Tiles 等多种要素时，鼠标拾取时可能会拾取到多个元素，如果想拾取单一元素时，可以使用 `instanceof` 方法来判断。

```typescript {7,10,13,16}
const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

handler.setInputAction((e) => {
  const picked = viewer.scene.pick(e.position);

  if (Cesium.defined(picked)) {
    if (picked.id && picked.id instanceof Cesium.Entity) {
      console.log("选中了Entity", picked);
    }
    if (picked.primitive instanceof Cesium.Primitive) {
      console.log("选中了Primitive", picked);
    }
    if (picked.primitive instanceof Cesium.Model) {
      console.log("选中了Model", picked);
    }
    if (picked instanceof Cesium.Cesium3DTileFeature) {
      console.log("选中了3DTiles", picked);
    }
  }
}, cesium.ScreenSpaceEventType.LEFT_CLICK);
```



### 图层添加事件

```typescript {22}
viewer.scene.primitives.add(
  new Cesium.Primitive({
    geometryInstances: new Cesium.GeometryInstance({
      id: "rectangle",
      name: 'rectangle',
      geometry: new Cesium.RectangleGeometry({
        rectangle: Cesium.Rectangle.fromDegrees(-100.0, 30.0, -90.0, 40.0)
      }),
      attributes: {
        color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.RED)
      }
    }),
    appearance: new Cesium.PerInstanceColorAppearance()
  })
);

const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

handler.setInputAction((e) => {
  const pick = viewer.scene.pick(e.position);
  // 按照图层属性进行事件触发条件过滤
  if (Cesium.defined(pick) && pick.name === "rectangle") {
    console.log("Mouse clicked rectangle.");
  }
}, cesium.ScreenSpaceEventType.LEFT_CLICK);
```



## 相机事件

相机事件类 [`screenSpaceCameraController`](https://cesium.com/learn/cesiumjs/ref-doc/ScreenSpaceCameraController.html?classFilter=screen) 不像鼠标事件类那样需要提前实例化。

Cesium 在 Viewer 类的实例化过程中，也实例化了其他很多类，其中就包括了该类，并把实例化结果赋值给了 `viewer.scene.screenSpaceCameraController`。



### 鼠标控制相机

通过鼠标控制相机的方式取决于 CameraEventType 的常量，包括以下几种：

|  事件类型   | 作用                                 |
| :---------: | :----------------------------------- |
|  LEFT_DRAG  | 按住鼠标左键，然后移动鼠标并释放按钮 |
| MIDDLE_DRAG | 按住鼠标中键，然后移动鼠标并释放按钮 |
| RIGHT_DRAG  | 按住鼠标右键，然后移动鼠标并释放按钮 |
|    PINCH    | 触摸表面上的双指触摸                 |
|    WHEEL    | 滚动鼠标中键                         |

```typescript
// 删除默认的鼠标事件
globalData.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
globalData.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
globalData.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

// 修改鼠标点击事件
globalData.viewer.scene.screenSpaceCameraController.tiltEventTypes = [
  Cesium.CameraEventType.RIGHT_DRAG,
  Cesium.CameraEventType.PINCH,
  {
    eventType: Cesium.CameraEventType.LEFT_DRAG,
    modifier: Cesium.KeyboardEventModifier.CTRL
  },
  {
    eventType: Cesium.CameraEventType.RIGHT_DRAG,
    modifier: Cesium.KeyboardEventModifier.CTRL
  }
];

// 修改视图缩放事件
globalData.viewer.scene.screenSpaceCameraController.zoomEventTypes = [
  Cesium.CameraEventType.MIDDLE_DRAG,
  Cesium.CameraEventType.WHEEL,
  Cesium.CameraEventType.PINCH
];
```



### 键盘控制相机

通过操作键盘实现相机的漫游，比如前进、后退、向上、向下等。

Cesium 中实现键盘漫游主要通过调用相机的 `moveForward`、`moveBackward`、`moveLeft`、`moveRight`、`moveUp`、`moveDown` 方法。

::: details 相机漫游

```typescript {32,35,38,41,44,47}
let startMousePosition: any;
let mousePosition: any;
const flags = {
  looking: false,
  moveForward: false,
  moveBackward: false,
  moveUp: false,
  moveDown: false,
  moveLeft: false,
  moveRight: false,
};

viewer.clock.onTick.addEventListener((_e: any) => {
  const camera = viewer.camera;

  if (flags.looking) {
    const width = viewer.canvas.width;
    const height = viewer.canvas.height;

    const x = (mousePosition.x - startMousePosition.x) / width;
    const y = (mousePosition.y - startMousePosition.y) / height;

    const lookFactor = 0.05;
    viewer.camera.lookRight(x * lookFactor);
    viewer.camera.lookUp(y * lookFactor);
  }

  const cameraHeight = viewer.scene.globe.ellipsoid.cartesianToCartographic(viewer.camera.position).height;
  const moveRate = cameraHeight / 100.0;

  if (flags.moveForward) {
    viewer.camera.moveForward(moveRate);
  }
  if (flags.moveBackward) {
    viewer.camera.moveBackward(moveRate);
  }
  if (flags.moveUp) {
    viewer.camera.moveUp(moveRate);
  }
  if (flags.moveDown) {
    viewer.camera.moveDown(moveRate);
  }
  if (flags.moveLeft) {
    viewer.camera.moveLeft(moveRate);
  }
  if (flags.moveRight) {
    viewer.camera.moveRight(moveRate);
  }
});

document.addEventListener("keydown", e => {
  const flagName = getFlagForKeyCode(e.code);
  if (typeof flagName !== "undefined") {
    flags[flagName] = true;
  }
});

document.addEventListener("keyup", e => {
  const flagName = getFlagForKeyCode(e.code);
  if (typeof flagName !== "undefined") {
    flags[flagName] = false;
  }
});

function getFlagForKeyCode(code: string) {
  switch (code) {
    case "KeyW":
      return "moveForward";
    case "KeyS":
      return "moveBackward";
    case "KeyQ":
      return "moveUp";
    case "KeyE":
      return "moveDown";
    case "KeyD":
      return "moveRight";
    case "KeyA":
      return "moveLeft";
    default:
      return undefined;
  }
}
```

:::



### 键盘控制调试功能

```typescript
document.addEventListener("keydown", e => {
  switch (e.code) {
    case "KeyR": // 切换线框模式
      if (viewer.scene) {
        const tileProvider = viewer.scene.globe._surface.tileProvider;
        tileProvider._debug.wireframe = !tileProvider._debug.wireframe;
      }
      break;
    case "KeyF": // 切换FPS显示
      if (viewer.scene) {
        viewer.scene.debugShowFramesPerSecond = !viewer.scene.debugShowFramesPerSecond;
      }
      break;
    case "KeyT": // 切换地形光照
      if (viewer.scene) {
        viewer.scene.globe.enableLighting = !viewer.scene.globe.enableLighting;
        console.log("地形光照:", viewer.scene.globe.enableLighting ? "开启" : "关闭");
      }
      break;
    case "KeyP": // 性能统计
      if (viewer.scene) {
        viewer.scene.debugShowCommands = !viewer.scene.debugShowCommands;
        console.log("渲染命令统计:", viewer.scene.debugShowCommands ? "开启" : "关闭");
      }
      break;
    case "KeyC": // 相机信息
      if (viewer.camera) {
        const position = viewer.camera.position;
        const cartographic = Cesium.Cartographic.fromCartesian(position);
        console.log("相机位置 - 经度:", Cesium.Math.toDegrees(cartographic.longitude).toFixed(6),
                    "纬度:", Cesium.Math.toDegrees(cartographic.latitude).toFixed(6),
                    "高度:", cartographic.height.toFixed(2));
      }
      break;
  }
});
```



## 场景渲染事件

场景渲染事件主要包括以下四种：

|       事件       | 作用                                       |
| :--------------: | ------------------------------------------ |
| scene.preUpdate  | 更新或呈现场景之前将引发的事件             |
| scene.postUpdate | 场景更新后，以及渲染场景之前立即引发的事件 |
| scene.preRender  | 场景更新后，以及渲染场景之前将引发的事件   |
| scene.postRender | 渲染场景后立即引发的事件                   |

```typescript
// 更新或呈现场景之前将引发的事件
viewer.scene.preUpdate.addEventListener(callbackFunc)
viewer.scene.preUpdate.removeEventListener(callbackFunc)

// 场景更新后，以及渲染场景之前立即引发的事件
viewer.scene.postUpdate.addEventListener(callbackFunc)
viewer.scene.postUpdate.removeEventListener(callbackFunc)

// 场景更新后，以及渲染场景之前将引发的事件
viewer.scene.preRender.addEventListener(callbackFunc)
viewer.scene.preRender.removeEventListener(callbackFunc)

// 渲染场景后立即引发的事件
viewer.scene.postRender.addEventListener(callbackFunc)
viewer.scene.postRender.removeEventListener(callbackFunc)

function callbackFunc(e: any) {
  console.log(e)
}
```
