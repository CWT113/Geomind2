# 平移、旋转和缩放

## 平移

所谓“平移”，无非是对图形的每个顶点做什么样的操作。例如，将点 p(x, y, z) 平移到 p<sub>1</sub>(x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>)，就是在 X 轴、Y 轴、Z 轴三个方向上平移的距离分别为 T<sub>x</sub>、T<sub>y</sub>、T<sub>z</sub>，其中 T<sub>z</sub> 为 0.0。

那么在坐标的对应分量上，直接加上这些 <span class="marker-text-highlight">T值（偏移值）</span>，就可以确定 p<sub>1</sub> 的坐标了，如下：

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; x<sub>1</sub> = x + T<sub>x</sub>

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; y<sub>1</sub> = y + T<sub>y</sub>

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; z<sub>1</sub> = z + T<sub>z</sub>

<img src="./assets/PixPin_2025-10-10_22-27-02.png" alt="PixPin_2025-10-10_22-27-02" style="zoom: 50%;diaplay:block;margin:auto;" />

下面的案例创建了一个三角形，并在 X 轴和 Y 轴方向上各增加了 0.5 个分量：

```html {29,32,85,87,92,95}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>平移</title>
  </head>
  <body>
    <canvas id="example" width="400" height="400">
      请使用支持 canvas 的浏览器查看
    </canvas>

    <script>
      const canvas = document.getElementById("example");
      if (!canvas) {
        console.log("Failed to load canvas element.");
      }
      // 获取 webgl 绘图上下文
      const gl = canvas.getContext("webgl");

      // 设置清空背景颜色
      gl.clearColor(0, 0, 0, 1);
      // 清空 canvas 背景
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 创建顶点着色器
      const VSHADER_SOURCE = `
        attribute vec4 a_Position;
        // 平移分量
        uniform vec4 u_Translation;

        void main() {
          gl_Position = a_Position + u_Translation;
        }
      `;
      const vShader = gl.createShader(gl.VERTEX_SHADER);
      // 向顶点着色器中填充着色器程序源码
      gl.shaderSource(vShader, VSHADER_SOURCE);
      // 编译顶点着色器
      gl.compileShader(vShader);

      // 创建片段着色器
      const FSHADER_SOURCE = `
        void main() {
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
      `;
      const fShader = gl.createShader(gl.FRAGMENT_SHADER);
      // 向片元着色器中填充着色器程序源码
      gl.shaderSource(fShader, FSHADER_SOURCE);
      // 编译片元着色器
      gl.compileShader(fShader);

      // 创建程序对象
      const program = gl.createProgram();
      // 为程序对象分配着色器
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      // 连接程序对象
      gl.linkProgram(program);
      // 使用程序对象
      gl.useProgram(program);

      // 定义顶点数据，每2个组成一个点，一共3组点
      const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);
      const n = 3; // 点的个数

      // 创建缓冲区
      const buffer = gl.createBuffer();
      // 将缓冲区对象绑定到目标
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // 向缓冲区对象中写入数据
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // 获取 a_Position 变量的存储地址
      const a_Position = gl.getAttribLocation(program, "a_Position");
      if (a_Position < 0) {
        console.log("Failed to get storage location of a_Position");
      }
      // 将缓冲区对象分配给 a_Position 变量
      gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
      // 连接 a_Position 变量与分配给它的缓冲区对象
      gl.enableVertexAttribArray(a_Position);

      // 定义平移的分量
      const Tx = 0.5, Ty = 0.5, Tz = 0.0;
      // 获取 u_Translation 变量的存储地址
      const u_Translation = gl.getUniformLocation(program, "u_Translation");
      if (!u_Translation) {
        console.log("Failed to get storage location of u_Translation");
      }
      // 分配变量值
      gl.uniform4f(u_Translation, Tx, Ty, Tz, 0.0);

      // 用三个点依次绘制一个三角形
      gl.drawArrays(gl.TRIANGLES, 0, n);
    </script>
  </body>
</html>
```

> [!NOTE] 提示
>
> 1. 由于 T <sub> x </sub>、T <sub> y </sub>、T <sub> z </sub> 对于所有顶点都是固定的，所以这里使用 `uniform` 变量来表示三角形的平移距离。
> 1. `uniform` 变量使用了 `vec4` 作为类型，它的好处是和 `a_Position` 变量的类型一致，可以直接做相加，相对应的矢量分量会被同时相加。
> 1. 需要注意的是，在 `gl.uniform4f(u_Translation, Tx, Ty, Tz, 0.0);` 时，第 4 分量这里设置为 0.0，而不是 1.0。这是因为 `a_Position` 的第 4 分量默认已经是 1.0，而相加后的第 4 分量总和也必须为 1.0，所以 `uniform4f()` 中只能是 0.0。 

![PixPin_2025-10-10_23-24-04](./assets/PixPin_2025-10-10_23-24-04.png)



## 旋转

旋转比平移要复杂一些，首先需要指明以下三点：

- **旋转轴**（图形将围绕旋转轴旋转）
- **旋转方向**（顺时针或逆时针）
- **旋转角度**（图形旋转经过的角度）



在 WebGL 中，默认使用 **右手旋转法则（逆时针旋转）**，即<span class="marker-text-highlight">右手握拳，大拇指朝向眼睛代表 Z轴，其余手指的方向就是旋转的方向</span>。

| <img src="./assets/PixPin_2025-10-10_23-12-56.png" alt="PixPin_2025-10-10_23-12-56" style="diaplay:block;margin:auto;"/> | ![PixPin_2025-10-12_12-06-52](./assets/PixPin_2025-10-12_12-06-52.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

计算旋转后的坐标，需要使用到三角函数的内容，简化后的公式如下所示：

```latex
x' = x cosβ - y sinβ
y' = x sinβ + y cosβ
z' = z
```

我们只需要把 `sinβ` 和 `cosβ` 的值传递给顶点着色器，然后顶点着色器按照上述公式计算旋转后的点坐标，就可以实现旋转的效果了。



下面案例创建了一个三角形，并沿着 Z轴方向旋转了 45°：

::: code-group

```html [基础版本] {28,31-34,86-89,91,92,94,95}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>旋转</title>
  </head>
  <body>
    <canvas id="example" width="400" height="400">
      请使用支持 canvas 的浏览器查看
    </canvas>

    <script>
      const canvas = document.getElementById("example");
      if (!canvas) {
        console.log("Failed to load canvas element.");
      }
      // 获取 webgl 绘图上下文
      const gl = canvas.getContext("webgl");

      // 设置清空背景颜色
      gl.clearColor(0, 0, 0, 1);
      // 清空 canvas 背景
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 创建顶点着色器
      const VSHADER_SOURCE = `
        attribute vec4 a_Position;
        uniform float u_CosB, u_SinB;

        void main() {
          gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB;
          gl_Position.y = a_Position.x * u_SinB + a_Position.y * u_CosB;
          gl_Position.z = a_Position.z;
          gl_Position.w = 1.0;
        }
      `;
      const vShader = gl.createShader(gl.VERTEX_SHADER);
      // 向顶点着色器中填充着色器程序源码
      gl.shaderSource(vShader, VSHADER_SOURCE);
      // 编译顶点着色器
      gl.compileShader(vShader);

      // 创建片段着色器
      const FSHADER_SOURCE = `
        void main() {
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
      `;
      const fShader = gl.createShader(gl.FRAGMENT_SHADER);
      // 向片元着色器中填充着色器程序源码
      gl.shaderSource(fShader, FSHADER_SOURCE);
      // 编译片元着色器
      gl.compileShader(fShader);

      // 创建程序对象
      const program = gl.createProgram();
      // 为程序对象分配着色器
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      // 连接程序对象
      gl.linkProgram(program);
      // 使用程序对象
      gl.useProgram(program);

      // 定义顶点数据，每2个组成一个点，一共3组点
      const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);
      const n = 3; // 点的个数

      // 创建缓冲区
      const buffer = gl.createBuffer();
      // 将缓冲区对象绑定到目标
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // 向缓冲区对象中写入数据
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // 获取 a_Position 变量的存储地址
      const a_Position = gl.getAttribLocation(program, "a_Position");
      if (a_Position < 0) {
        console.log("Failed to get storage location of a_Position");
      }
      // 将缓冲区对象分配给 a_Position 变量
      gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
      // 连接 a_Position 变量与分配给它的缓冲区对象
      gl.enableVertexAttribArray(a_Position);

      const ANGLE = 45;
      const radian = Math.PI * ANGLE / 180.0; // 转换为弧度制
      const cosB = Math.cos(radian);
      const sinB = Math.sin(radian);

      const u_CosB = gl.getUniformLocation(program, "u_CosB");
      const u_SinB = gl.getUniformLocation(program, "u_SinB");

      gl.uniform1f(u_CosB, cosB);
      gl.uniform1f(u_SinB, sinB);

      // 用三个点依次绘制一个三角形
      gl.drawArrays(gl.TRIANGLES, 0, n);
    </script>
  </body>
</html>
```

```html [优化版本] {28,31-34,86-89,92,93}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>旋转（版本2）</title>
  </head>
  <body>
    <canvas id="example" width="400" height="400">
      请使用支持 canvas 的浏览器查看
    </canvas>

    <script>
      const canvas = document.getElementById("example");
      if (!canvas) {
        console.log("Failed to load canvas element.");
      }
      // 获取 webgl 绘图上下文
      const gl = canvas.getContext("webgl");

      // 设置清空背景颜色
      gl.clearColor(0, 0, 0, 1);
      // 清空 canvas 背景
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 创建顶点着色器
      const VSHADER_SOURCE = `
        attribute vec4 a_Position;
        uniform vec2 u_CosBSinB;

        void main() {
          gl_Position.x = a_Position.x * u_CosBSinB.x - a_Position.y * u_CosBSinB.y;
          gl_Position.y = a_Position.x * u_CosBSinB.y + a_Position.y * u_CosBSinB.x;
          gl_Position.z = a_Position.z;
          gl_Position.w = 1.0;
        }
      `;
      const vShader = gl.createShader(gl.VERTEX_SHADER);
      // 向顶点着色器中填充着色器程序源码
      gl.shaderSource(vShader, VSHADER_SOURCE);
      // 编译顶点着色器
      gl.compileShader(vShader);

      // 创建片段着色器
      const FSHADER_SOURCE = `
        void main() {
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
      `;
      const fShader = gl.createShader(gl.FRAGMENT_SHADER);
      // 向片元着色器中填充着色器程序源码
      gl.shaderSource(fShader, FSHADER_SOURCE);
      // 编译片元着色器
      gl.compileShader(fShader);

      // 创建程序对象
      const program = gl.createProgram();
      // 为程序对象分配着色器
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      // 连接程序对象
      gl.linkProgram(program);
      // 使用程序对象
      gl.useProgram(program);

      // 定义顶点数据，每2个组成一个点，一共3组点
      const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);
      const n = 3; // 点的个数

      // 创建缓冲区
      const buffer = gl.createBuffer();
      // 将缓冲区对象绑定到目标
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // 向缓冲区对象中写入数据
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // 获取 a_Position 变量的存储地址
      const a_Position = gl.getAttribLocation(program, "a_Position");
      if (a_Position < 0) {
        console.log("Failed to get storage location of a_Position");
      }
      // 将缓冲区对象分配给 a_Position 变量
      gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
      // 连接 a_Position 变量与分配给它的缓冲区对象
      gl.enableVertexAttribArray(a_Position);

      const ANGLE = 45;
      const radian = Math.PI * ANGLE / 180.0; // 转换为弧度制
      const cosB = Math.cos(radian);
      const sinB = Math.sin(radian);
      
      // 只需要获取一个变量
      const u_CosBSinB = gl.getUniformLocation(program, "u_CosBSinB");
      gl.uniform2f(u_CosBSinB, cosB, sinB);

      // 用三个点依次绘制一个三角形
      gl.drawArrays(gl.TRIANGLES, 0, n);
    </script>
  </body>
</html>
```

:::

![PixPin_2025-10-10_23-23-40](./assets/PixPin_2025-10-10_23-23-40.png)



## 变换矩阵

> 对于简单的变换，可以使用上述的数学表达式来实现。但是当情形变得复杂时（如将案例中的三角形“先旋转后平移”），用数学表达式的方式将会变得非常繁琐。 

**变换矩阵**（Transformation matrix）就是专门用于<span class="marker-text-highlight">执行复杂的图形变换的，它使用线性代数中的矩阵来计算图形变换后结果</span>。

### 矩阵旋转

矩阵和矢量的乘法可以写成下面的形式，通过 “×”号，**矩阵**（中间）和**矢量**（右边）相乘，就得到了**新的矢量**（左边）。
$$
\begin{bmatrix}
x' \\
y' \\
z'
\end{bmatrix}

= 

\begin{bmatrix}
a & b & c \\
d & e & f \\
g & h & i
\end{bmatrix}

×

\begin{bmatrix}
x \\
y \\
z
\end{bmatrix}

\tag{1}
$$
上面的矩阵与矢量相乘，本质上是执行以下数学公式：

```latex
x' = ax + by + cz
y' = dx + ey + fz
z' = gx + hy + iz

% 特殊地，当 a = cosβ，b = -sinβ，c = 0 时
x' = ax + by + cz  <==>  x' = xcosβ - bsinβ
% 特殊地，当 d = sinβ，e = cosβ，c = 0 时
y' = dx + ey + fz  <==>  y' = xsinβ + ycosβ
```

接下来，将这些结果带入到上面的矩阵（1）中，得到 **旋转矩阵** 如下所示：
$$
\begin{bmatrix}
x' \\
y' \\
z'
\end{bmatrix}

= 

\begin{bmatrix}
\cos\beta & -\sin\beta & 0 \\
\sin\beta & \cos\beta & 0 \\
0 & 0 & 1
\end{bmatrix}

×

\begin{bmatrix}
x \\
y \\
z
\end{bmatrix}
$$



### 矩阵平移

既然旋转矩阵既能表示旋转，那么它也可以表示平移。正常的平移公式如下：

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; x<sub>1</sub> = x + T<sub>z</sub>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(1) 式

这里的等式中出现了常量 T<sub>z</sub>，这意味着无法通过 3 × 3 的矩阵来表示平移了。此时需要使用 4 × 4 的矩阵，并且矩阵的第 4 分量需要设为 1.0。如下所示：
$$
\begin{bmatrix}
x' \\
y' \\
z' \\
1
\end{bmatrix}

= 

\begin{bmatrix}
a & b & c & d \\
e & f & g & h \\
i & j & k & l \\
m & n & o & p
\end{bmatrix}

×

\begin{bmatrix}
x \\
y \\
z \\
1
\end{bmatrix}
$$
该矩阵的乘法结果如下所示：

```latex
x' = ax + by + cz + d                                                  (2) 式
y' = ex + fy + gz + h
z' = ix + jy + kz + l

% 有此可得出 m = n = o = 0，而 p = 1
1 = mx + ny + oz + p
```

结合 (1) 式 和 (2) 式，如果两者同时成立，可知 a = 1，b = c = 0，d = T<sub>z</sub>。类似的 y 和 z 的计算方式相同。

由此可得出 **平移矩阵** 如下所示：
$$
\begin{bmatrix}
x' \\
y' \\
z' \\
1
\end{bmatrix}

= 

\begin{bmatrix}
1 & 0 & 0 & T_x \\
0 & 1 & 0 & T_y \\
0 & 0 & 1 & T_z \\
0 & 0 & 0 & 1
\end{bmatrix}

×

\begin{bmatrix}
x \\
y \\
z \\
1
\end{bmatrix}
$$


### 4×4矩阵

至此，上面已经介绍了旋转矩阵（3 × 3矩阵）和平移矩阵（4 × 4矩阵）。因为二者的阶数不同，无法同时组合两个阶数不同的矩阵，所以需要将两个矩阵的阶数保持一致。

因此我们可以将 3 × 3 的旋转矩阵，也转换为 4 × 4 的矩阵，对比旋转和平移的公式：

```latex
% 旋转矩阵
x' = x cosβ - y sinβ                                              (1) 式
y' = x sinβ + y cosβ
z' = z

% 平移矩阵
x' = ax + by + cz + d                                             (2) 式
y' = ex + fy + gz + h
z' = ix + jy + kz + l
1 = mx + ny + oz + p
```

对比 (1) 式和 (2) 式，可以得出 a = cosβ，b = -sinβ，c = d = 0 = T<sub>x</sub>。依次类推，得到 **结合旋转和平移** 的 4 × 4 矩阵如下：
$$
\begin{bmatrix}
x' \\
y' \\
z' \\
1
\end{bmatrix}

= 

\begin{bmatrix}
cosβ & -sinβ & 0 & T_x \\
sinβ & cosβ & 0 & T_y \\
0 & 0 & 1 & T_z \\
0 & 0 & 0 & 1
\end{bmatrix}

×

\begin{bmatrix}
x \\
y \\
z \\
1
\end{bmatrix}
$$

> [!NOTE] 提示
>
> - 特殊地，当 cosβ = sibβ = 0，而 T<sub>x</sub> = T<sub>y</sub> = T<sub>z</sub> ≠ 0 时，表示纯平移矩阵；
> - 特殊地，当 T<sub>x</sub> = T<sub>y</sub> = T<sub>z</sub> = 0，而 cosβ = sibβ ≠ 0 时，表示纯旋转矩阵；



下面的案例同时结合了旋转和平移：

```html {28,31,91-96,99,100}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>旋转和平移</title>
  </head>
  <body>
    <canvas id="example" width="400" height="400">
      请使用支持 canvas 的浏览器查看
    </canvas>

    <script>
      const canvas = document.getElementById("example");
      if (!canvas) {
        console.log("Failed to load canvas element.");
      }
      // 获取 webgl 绘图上下文
      const gl = canvas.getContext("webgl");

      // 设置清空背景颜色
      gl.clearColor(0, 0, 0, 1);
      // 清空 canvas 背景
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 创建顶点着色器
      const VSHADER_SOURCE = `
        attribute vec4 a_Position;
        uniform mat4 u_xformMatrix; // mat4 表示4×4的矩阵类型

        void main() {
          gl_Position = u_xformMatrix * a_Position;
        }
      `;
      const vShader = gl.createShader(gl.VERTEX_SHADER);
      // 向顶点着色器中填充着色器程序源码
      gl.shaderSource(vShader, VSHADER_SOURCE);
      // 编译顶点着色器
      gl.compileShader(vShader);

      // 创建片段着色器
      const FSHADER_SOURCE = `
        void main() {
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
      `;
      const fShader = gl.createShader(gl.FRAGMENT_SHADER);
      // 向片元着色器中填充着色器程序源码
      gl.shaderSource(fShader, FSHADER_SOURCE);
      // 编译片元着色器
      gl.compileShader(fShader);

      // 创建程序对象
      const program = gl.createProgram();
      // 为程序对象分配着色器
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      // 连接程序对象
      gl.linkProgram(program);
      // 使用程序对象
      gl.useProgram(program);

      // 定义顶点数据，每2个组成一个点，一共3组点
      const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);
      const n = 3; // 点的个数

      // 创建缓冲区
      const buffer = gl.createBuffer();
      // 将缓冲区对象绑定到目标
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // 向缓冲区对象中写入数据
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // 获取 a_Position 变量的存储地址
      const a_Position = gl.getAttribLocation(program, "a_Position");
      if (a_Position < 0) {
        console.log("Failed to get storage location of a_Position");
      }
      // 将缓冲区对象分配给 a_Position 变量
      gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
      // 连接 a_Position 变量与分配给它的缓冲区对象
      gl.enableVertexAttribArray(a_Position);

      const ANGLE = 45;
      const radian = Math.PI * ANGLE / 180.0; // 转换为弧度制
      const cosB = Math.cos(radian);
      const sinB = Math.sin(radian);

      const Tx = 0.5, Ty = 0.5, Tz = 0.5;

      // 创建旋转矩阵（注意：WebGL中矩阵是按列主序的）
      const xformMatrix = new Float32Array([
        cosB, sinB, 0.0, 0.0,
        -sinB, cosB, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        Tx, Ty, Tz, 1.0,
      ]);

      // 只需要获取一个变量
      const u_xformMatrix = gl.getUniformLocation(program, "u_xformMatrix");
      gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix);

      // 用三个点依次绘制一个三角形
      gl.drawArrays(gl.TRIANGLES, 0, n);
    </script>
  </body>
</html>
```

> [!CAUTION] 注意
>
> -  `u_xformMatrix` 的类型为 `mat4`，它修饰的变量就代表 4 × 4 的矩阵；
> - 矩阵的顺序是按行主序，而在 `Float32Array` 中是按列主序，特别注意填写顺序；

::: details API：gl.getUniformLocation(location, transpose, array)

将 array 表示的 4 × 4 的矩阵分配给由 location 指定的 uniform 变量。

|   参数    | 描述                                            |
| :-------: | ----------------------------------------------- |
| location  | uniform 变量的存储位置                          |
| transpose | 在 WebGL 中必须指定为 false                     |
|   array   | 待传输的类型化数组，4 × 4矩阵按列主序存储在其中 |

:::

![PixPin_2025-10-12_11-59-52](./assets/PixPin_2025-10-12_11-59-52.png)



### 缩放

假设在三个方向X轴、Y轴、Z轴的缩放因子是S<sub>x</sub>、S<sub>y</sub>、S<sub>z</sub>，那么计算缩放坐标的公式如下：

 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;x<sub>1</sub> = x × S<sub>x</sub>

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; y<sub>1</sub> = y × S<sub>y</sub>

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; z<sub>1</sub> = z × S<sub>z</sub>

由此，可得出缩放操作的变换矩阵如下所示：
$$
\begin{bmatrix}
x' \\
y' \\
z' \\
1
\end{bmatrix}

= 

\begin{bmatrix}
S_x & 0 & 0 & 0 \\
0 & S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}

×

\begin{bmatrix}
x \\
y \\
z \\
1
\end{bmatrix}
$$
和上面的案例一样，我们将三角形缩放 1 倍：

```html {28,31,86-91,94,95}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>缩放</title>
  </head>
  <body>
    <canvas id="example" width="400" height="400">
      请使用支持 canvas 的浏览器查看
    </canvas>

    <script>
      const canvas = document.getElementById("example");
      if (!canvas) {
        console.log("Failed to load canvas element.");
      }
      // 获取 webgl 绘图上下文
      const gl = canvas.getContext("webgl");

      // 设置清空背景颜色
      gl.clearColor(0, 0, 0, 1);
      // 清空 canvas 背景
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 创建顶点着色器
      const VSHADER_SOURCE = `
        attribute vec4 a_Position;
        uniform mat4 u_xformMatrix;

        void main() {
          gl_Position = u_xformMatrix * a_Position;
        }
      `;
      const vShader = gl.createShader(gl.VERTEX_SHADER);
      // 向顶点着色器中填充着色器程序源码
      gl.shaderSource(vShader, VSHADER_SOURCE);
      // 编译顶点着色器
      gl.compileShader(vShader);

      // 创建片段着色器
      const FSHADER_SOURCE = `
        void main() {
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
      `;
      const fShader = gl.createShader(gl.FRAGMENT_SHADER);
      // 向片元着色器中填充着色器程序源码
      gl.shaderSource(fShader, FSHADER_SOURCE);
      // 编译片元着色器
      gl.compileShader(fShader);

      // 创建程序对象
      const program = gl.createProgram();
      // 为程序对象分配着色器
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      // 连接程序对象
      gl.linkProgram(program);
      // 使用程序对象
      gl.useProgram(program);

      // 定义顶点数据，每2个组成一个点，一共3组点
      const vertices = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);
      const n = 3; // 点的个数

      // 创建缓冲区
      const buffer = gl.createBuffer();
      // 将缓冲区对象绑定到目标
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // 向缓冲区对象中写入数据
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // 获取 a_Position 变量的存储地址
      const a_Position = gl.getAttribLocation(program, "a_Position");
      if (a_Position < 0) {
        console.log("Failed to get storage location of a_Position");
      }
      // 将缓冲区对象分配给 a_Position 变量
      gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
      // 连接 a_Position 变量与分配给它的缓冲区对象
      gl.enableVertexAttribArray(a_Position);

      const Sx = 0.5, Sy = 0.5, Sz = 0.5;

      // 创建旋转矩阵（注意：WebGL中矩阵是按列主序的）
      const xformMatrix = new Float32Array([
        Sx, 0.0, 0.0, 0.0,
        0.0, Sy, 0.0, 0.0,
        0.0, 0.0, Sz, 0.0,
        0.0, 0.0, 0.0, 1.0,
      ]);

      // 只需要获取一个变量
      const u_xformMatrix = gl.getUniformLocation(program, "u_xformMatrix");
      gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix);

      // 用三个点依次绘制一个三角形
      gl.drawArrays(gl.TRIANGLES, 0, n);
    </script>
  </body>
</html>
```

![PixPin_2025-10-12_15-03-44](./assets/PixPin_2025-10-12_15-03-44.png)
